<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记发现一个ArrayList的Bug]]></title>
    <url>%2F2018%2F06%2F18%2FbugOfArrayList%2F</url>
    <content type="text"><![CDATA[事先声明,本文内容相对枯燥难懂,这个Bug也并不严重,在此主要是为了记录一下发现JDK bug的经历. 最近在阅读ArrayList动态扩容的代码时，发现了一个小bug，这个bug直到1.8才被发现(1.7也存在)，在java9中被修复。Bug地址https://bugs.openjdk.java.net/browse/JDK-8146568/. 背景是这样的：ArrayList有个一方法addAll,将一个集合中的所有元素添加到list中。然后addAll会调用ensureCapacityInternal来保证ArrayList足够大,以容下新增的元素.当list和被添加的集合大小足够大时可能就会触发这个Bug,抛出NegativeIndexException这样一个错误的异常,而不是抛出OurOfMemoeryError. 其中minCapacity是新数组所需的最小容量,newCapacity是根据ArrayList扩容机制产生的新数组的大小. 123456789public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; //ccc注: 注意此处有可能会出现两个大的int值相加,溢出,从而得到一个负数 ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 紧接着会调用以下一系列方法. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code (注:原注释表示这段代码已经考虑了整数溢出) if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit * * ccc注: 在JVM中,数组的长度的最大值一般小于Integer.MAX_VALUE,如果超过该限制,则会抛出异常. * 所以为了保险,设置数组的大小上限为Integer.MAX_VALUE - 8 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code (注:原注释表示这段代码已经考虑了整数溢出) int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 由于未知原因(猜测是为了提高代码执行速度),原本并不复杂的动态扩容的grow方法由于兼容整数溢出的情形,使得代码的逻辑异常复杂,几乎无法阅读. 为了分析这段代码,可以分为以下几个情况: 正常情况. minCapacity没有出现溢出,newCapacity也没有出现溢出 12345678910111213private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; // 将新的数组大小设置为原大小的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果新的数组大小仍然小于所需的最小容量,则将新的数组大小设置为最小容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新的数组大小大于ArrayList中设置的数组大小上限则调用hugeCapaticy生成最终的数组大小 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; minCapacity发生溢出,newCapacity没有溢出. 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; /* * 这个地方由于溢出minCapacity是负数,那么minCapacity是负数是否会导致 * 这里的if判断错误呢(例如负数-正数结果为负数,于是跳过grow方法)? 我们知道 * minCapacity = size + numNew(添加进来的集合的大小),而size &lt;= elementData.length, * 所以 minCapacity - elementData.length = size + numNew - elementData.length = * numNew - (elementData.length - size) * 所以次表达式判断新增的元素数量大小 numNew 是否大于原本数组中空闲的大小 * elementData - size.而两者都是正数所以说 minCapacity 是否是溢出并不影响判断结果. */ // overflow-conscious code (注:原注释表示这段代码已经考虑了整数溢出) // 判断所需最小容量是否小于目前数组的长度,如果是,则无需扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;private void grow(int minCapacity) &#123; // overflow-conscious code (注:原注释表示这段代码已经考虑了整数溢出) int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); /* * newCapacity - minCapacity = newCapacity - (size + numNew) = -(size + numNew - newCapacity) * 因为 0 &lt; size &lt; newCapacity &lt; Integer.MAX_VALUE(未溢出). 所以 size + numNew - newCapacity &gt; 0. * 所以 newCapacity(正数) - minCapacity(负数) &lt; 0,这里意味着 newCapacity - minCapacity 又再一次溢出, * 使得 newCapacity 被赋值为 minCapacity. * * */ if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; /* * minCapacity - MAX_ARRAY_SIZE,由于 newCapacity 未溢出,所以 oldCapacity &lt; (2/3)*Integer.MAX_VALUE * 而由于 size &lt; oldCapacity &lt; (2/3)*Integer.MAX_VALUE, newNum &lt; Integer.MAX_VALUE, * minCapacity = size + newNum. 所以 -Integer.MAX_VALUE &lt; minCapacity &lt; -(2/3)Integer.MAX_VALUE. * 所以 newCapacity - MAX_ARRAY_SIZE 必然会再次溢出,进入到hugeCapacity方法 * * */ if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; minCapacity没有溢出,newCapacity溢出 12345678910111213141516171819202122private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); /* * 由于 newCapacity 发生溢出,所以oldCapacity &gt; (2/3)Integer.MAX_VALUE * 而 0 &lt;= minCapacity &lt; Integer.MAX_VALUE. * 所以 newCapacity - minCapacity 可能出现两种情况 * 溢出: newCapacity 不变,为溢出导致的负数数 * 由于 newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) ,且 newCapacity * 溢出,所以 -Integer.MAX_VALUE &lt; newCapacity &lt; -1.5*Integer.MAX_VALUE. * 所以 newCapacity - MAX_ARRAY_SIZE 必然再次溢出,进入到hugeCapacity. * 未溢出: newCapacity 被赋值为 minCapacity(正数),也就是新的容量为所需最小容量 * 之后的逻辑正常 * */ if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; minCapacity 和 newCapacity 都溢出了.这种情况可能会出现Bug 123456789101112131415161718192021222324252627282930private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); /* * -Integer.MAX_VALUE &lt; newCapacity &lt; -1.5*Integer.MAX_VALUE * -Integer.MAX_VALUE &lt; minCapacity &lt; 0 * 由于 minCapacity 和 newCapacity 都是负数,所以不会发生溢出的情况 * 这里 newCapacity - minCapacity 大于零和小于零都是可能的. * 如果 newCapacity - minCapacity &gt; 0 : * 则 newCapacity 不变,newCapacity - MAX_ARRAY_SIZE 必然溢出,进 * 入到hugeCapacity方法. * 如果 newCapacity - minCapacity &lt; 0 : * 则 newCapacity 被复制为 minCapacity ,而 minCapacity 范围是 * -Integer.MAX_VALUE &lt; minCapacity &lt; 0,而 MAX_ARRAY_SIZE = * Integer.MAX_VALUE - 8.所以当 -8 &lt; minCapacity &lt; 0 时, * newCapacity - MAX_ARRAY_SIZE 是不会溢出的 , 且会不进入到hugeCapacity * 所以 newCapacity 最终仍然为负数,所以会引发 NegativeArraySizeException * 而不是抛出 OutOfMemoryError.当调用 allAll 时出现 NegativeArraySizeException * 显然是让人疑惑的. * * * */ if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 当然,出现以上Bug的条件是十分苛刻的.要使得-8 &lt; minCapacity &lt; 0,则调用addAll时,原数组大小加上添加的集合大小足够大,两者之和需要大于2倍的Integer.MAX_VALUE-4.而可能由于JVM的限制根本没有这么大的数组,并且初始化如此大的数组需要很大的内存. 可以用如下代码验证此Bug,前提是你的JVM中数组大小的上限大于Integer.MAX_VALUE-4.我机器是 mac OS X ,java版本为 1.8.0_131. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class ArrayList &#123; /** * 在我机器上,实际的数组大小上限 * actual max array size on my machine, depends on JVM */ private static int JVM_MAX_ARRAY_SIZE = Integer.MAX_VALUE - 2; /** * 当前数组的长度 */ private static int LENGTH = JVM_MAX_ARRAY_SIZE; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; public static void main(String... args) &#123; // 验证JVM的数组大小上限 boolean[] maxSizeArray = new boolean[JVM_MAX_ARRAY_SIZE]; // 被添加的集合的大小 int numNew = JVM_MAX_ARRAY_SIZE; ensureExplicitCapacity(JVM_MAX_ARRAY_SIZE + numNew); &#125; private static void ensureExplicitCapacity(int minCapacity) &#123; // overflow-conscious code if (minCapacity - LENGTH &gt; 0) grow(minCapacity); &#125; private static void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = LENGTH; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 打印出最终数组的容量 System.out.println(newCapacity); int[] ints = new int[newCapacity]; &#125; private static int hugeCapacity(int minCapacity) &#123; // overflow if (minCapacity &lt; 0) throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;&#125; 总结我们应该避免为了一点无关紧要的效率,写出让人无法阅读的代码,从而让bug得以藏身.即使是JDK的作者,也会犯这样的错误.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
